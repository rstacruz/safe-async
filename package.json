{
  "name": "safe-async",
  "description": "Provides a standard interface for async APIs that supports promises, callbacks and catches errors properly.",
  "keywords": [
    "async",
    "asynchronous",
    "promise",
    "callback"
  ],
  "author": {
    "name": "Rico Sta. Cruz",
    "email": "hi@ricostacruz.com"
  },
  "version": "0.1.1",
  "repository": {
    "type": "git",
    "url": "https://github.com/rstacruz/safe-async.git"
  },
  "main": "index",
  "scripts": {
    "test": "./node_modules/.bin/mocha -R spec --recursive --compilers coffee:coffee-script"
  },
  "devDependencies": {
    "mocha": "*",
    "chai": "*",
    "coffee-script": "*",
    "sinon": "*",
    "q": "0.9.x",
    "when": "2.x.x",
    "promise": "3.x.x",
    "rsvp": "2.x.x"
  },
  "license": "MIT",
  "readme": "safe-async.js\n=============\n\n**Provides a standard interface for async APIs with useful features.**\n\nIt catches errors for you. It makes your async functions work with promises or \ncallbacks. In essence: it helps you write useful async API.\n\n[![Travis](https://travis-ci.org/rstacruz/safe-async.png?branch=master)](https://travis-ci.org/rstacruz/safe-async)\n\nWhen to use it\n--------------\n\n**Protip:** Any time you're writing a function that takes a callback, use\nsafe-async.js. Yes. All of them. Why?\n\n * __Ensures proper error propagation.__  \n No need for lots of try/catch blocks: those will be taken care of for you.\n\n * __Support promises or callbacks.__  \n It makes your functions work with both async callbacks or promises with no \n extra code.\n\n * __Portable.__   \n Works for Node.js and the browser. It's also pretty damn small (~70loc).\n\nWhen not to use it: when your library does its async duties with 100% promises\nand doesn't work with anything that expects callbacks. [q.js] already features\ngreat error handling (`q.try`). But then again, when is this ever the case?\n\nGet started in 20 seconds\n-------------------------\n\nInstall:\n\n~~~\n$ npm install safe-async\n~~~\n\nThen use it. Bonus: you can optionally hook in a promise provider if you want to\ntake advantage of the promise features. (See [safe.promise](#safepromise))\n\n~~~ js\nvar safe = require('safe-async');\nsafe.promise = require('q').promise;\n~~~\n\nInstead of writing an async function like so:\n\n~~~ js\n// Old-fashioned callback way\nx = function(a, b, c, done) {\n  if (success)\n    done(null, \"Result here\");\n  else\n    done(\"uh oh, error\");\n};\n~~~\n\nWrap that function in `safe` instead. (See [safe()](#safefn))\n\n~~~ js\n// New safe-async way\nx = safe(function(a, b, c, next) {\n  if (success)\n    next(\"Result here\");\n  else\n    throw \"uh oh, error\";\n});\n~~~\n\nWhen invoking another async function, wrap the callback in `next.wrap` too. This will catch\nerrors inside that function: (See [next.wrap()](#next-wrap))\n\n~~~ js\nx = safe(function(a, b, c, next) {\n  $.get('/', next.wrap(function() { /* <-- here */\n    if (success)\n      next(\"Result here\");\n    else\n      throw \"uh oh, error\";\n  });\n});\n~~~\n\nBonus: now your function can be used as a promise or a regular callback-powered async:\n\n~~~ js\n// Callback style\n// (called with a function as the last param)\nx(a, b, c, function(err, result) {\n  if (err)\n    console.log(\"Fail:\", err);\n  else\n    console.log(\"OK:\", result);\n});\n~~~\n\n~~~ js\n// Promise/A+ style\n// (called without a function in the last param)\nx(a, b, c)\n  .then(function(result) {\n    console.log(\"OK:\", result);\n  }, function(err) {\n    console.log(\"Fail:\", err);\n  });\n~~~\n\nWhat it's not\n-------------\n\n * It's not [async.js], because that lets you work many async callback-functions \n in parallel (among other things).\n\n * It's not [q.js] or [when.js] or [rsvp.js] or [promise.js],\nwhich helps you write promise functions and work with many promise objects.\nHowever, you can hook up safe-async to use any of those to generate\npromises.\n\nWhat it solves\n--------------\n\nWhat follows is a long-winding explanation of safe-async's reason for living. If\nyou're already convinced of its need for existence, skip on over to [API](#api).\n\n### Error catching\n\nPerhaps the most inelegant thing about asynchronous JavaScript callbacks is \nerror handling. Or rather: *proper* error handling.\n\nTo illustrate how this can get particularly hairy, let's start with an innocent \nfunction that expects a Node-style callback:\n\n~~~ js\n/**\n * Fetch the feed user (via AJAX) for a given `user`.\n */\ngetFeed = function(user, done) {\n  var id = user.name.toLowerCase();\n\n  $.get('/user/'+id+'/feeds.json', function(data) {\n    if (data.entries)\n      done(null, data);\n    else\n      done(\"No such user\");\n  });\n};\n~~~\n\nThis function expects an argument (`done`) callback that can be passed errors or \ndata. Great! It can return errors! This is the style that most of the Node.js \nAPI is written in (along with thousands of Node packages), so it's got to be a \ngood idea. Let's try to put it to test:\n\n~~~ js\nvar john = {\n  email: \"john@gmail.com\",\n  name: \"John\"\n};\n\ngetFeed(john, function(err, data) {\n  if (err) console.log(\"Error:\", err);\n  console.log(\"John's entries:\", data);\n});\n~~~\n\nWe just wrote a function that captures an errors (`if (err) ...`), or consumes \nthe data otherwise. That's got to work right! Until it does something \nunfortunately unexpected:\n\n~~~ js\nvar john = {\n  email: \"john@gmail.com\",\n  name: null  /* <-- uh oh. why doesn't he have a name? */\n}; \n\ngetFeed(john, function(err, data) {\n  if (err) console.log(\"Error:\", err);\n  console.log(\"John's entries:\", data);\n});\n~~~\n\n~~~ js\nTypeError: Cannot call method 'toLowerCase' of null\n  at feed.js:5 [var id = user.name.toLowerCase();]\n~~~\n\nGasp! Shouldn't this error have been caught and handled? Of course not--we never \nput any provisions to catch it. No problem, we can rewrite that `getFeed()` \nfunction to put its contents in a try/catch block.\n\n~~~ js\ngetFeed = function(user, done) {\n  try {\n    var id = user.name.toLowerCase();\n\n    $.get('/user/'+id+'/feeds.json', function(data) {\n      if (data.entries)\n        done(null, data);\n      else\n        done(\"No such user\");\n    });\n  }\n  catch (err) { /* <-- alright, let's relay some errors to the callback. */\n    done(err);\n  }\n});\n~~~\n\nThis works as expected, but wrapping all your functions in a try/catch blocks\ncat be a very cathartic exercise. Safe-async to the rescue! Simply wrap your\nfunction inside `safe(...)` and it'll take care of that for you.\n\nInstead of writing `x = function(a,b,c,done) { ... }`, use `x =\nsafe(function(a,b,c,next) { ...  });`.\n\n~~~ js\nvar safe = require('safe-async');\n\n// Wrap your function inside `safe(...)`.\ngetFeed = safe(function(user, next) {\n  var id = user.name.toLowerCase();\n\n  $.get('/user/'+id+'/feeds.json', function(data) {\n    if (data.entries)\n      next(data);\n    else\n      next.err(\"No such user\");\n  });\n});\n~~~\n\nNow you got your errors trapped and passed for you. Let's try to consume \n`getFeed()` again:\n\n~~~ js\nvar john = null;\ngetFeed(john, function(err, data) {\n  if (err) {\n    console.log(\"Uh oh! Caught an error.\");\n    console.log(\"=> \"+ err);\n    return;\n  }\n  console.log(\"John's entries:\", data);\n});\n~~~\n\nThis now catches the error in `err` as we expected.\n\n~~~ js\nUh oh! Caught an error.\n=> TypeError: Cannot call method 'toLowerCase' of null\n~~~\n\n### Deep error catching\n\n\"So what? We can easily write this decorator without safe-async,\" you may be \nthinking. In fact, it's this very line of thinking that got me to writing \nsafe-async in the first place.\n\nLet's move on to a more complex example. Let's say we're writing an async \nfunction to fetch some data, crunch it, and return it.\n\n~~~ js\n/*\n * Fetches posts and gets the title of the first post.\n */\ngetFirstPost = function(done) {\n  $.get('/posts.json', function(data) {\n    var post = data.entries[0].title;\n    done(null, post);\n  });\n};\n~~~\n\nLet's use it:\n\n~~~ js\ngetFirstPost(function(title) {\n  $(\"h1\").html(title);\n});\n~~~\n\nIt works, but it'll get you an unexpected result in some circumstances. What if \n`data.entries` is empty?\n\n~~~ js\nTypeError: Cannot read property 'title' of undefined\n  at getfirstpost.js:6 [data.entries[0].title]\n~~~\n\nUh oh: we have an error that happens in an async callback. We need to catch that \ntoo. Without safe-async, we may need to do 2 try/catch blocks: one for inside the \nfunction body, and another for inside the callback function's body. This is \nborderline asinine.\n\n~~~ js\ngetFirstPost = function(next) {\n  try {\n    $.get('/posts.json', function(data) {\n      try {\n        var post = data.entries[0].title;\n        next(null, post);\n      }\n      catch (err) {\n        next(err);\n      }\n    });\n  } catch (err) {\n    next(err);\n  }\n}\n~~~\n\nSafe-async provides a `next.wrap()` function that wraps any new callback for\nyou, which ensures that any errors it throws gets propagated properly. That\ncolossal function can be written more concisely with safe-async:\n\n~~~ js\ngetFirstPost = safe(function(next) {\n  $.get('/posts.json', next.wrap(function(data) {\n    var post = data.entries[0].title;\n    next(post);\n  }));\n});\n~~~\n\nWorking with promises\n---------------------\n\nGet Promise support by tying it in with your favorite Promise library. You can \nswap it out by changing [safe.promise](#safepromise) to the provider of \n[when.js], [q.js], [promise.js] or anything else that follows their API.\n\n~~~ js\nvar safe = require('safe-async');\n\nsafe.promise = require('q').promise;\nsafe.promise = require('when').promise;\nsafe.promise = require('promise');\n~~~\n\n### Call it with promises or not\n\nJust write any safe-async-powered async function and it can work with Node-style \ncallbacks or promises. The same `getFirstPost()` function we wrote can be used \nas a promise:\n\n~~~ js\n// As promises\ngetFirstPost()\n  .then(function(title) {\n    $(\"h1\").html(title);\n  });\n~~~\n\nor it can be invoked with a callback:\n\n~~~ js\n// As a Node-style async function\ngetFirstPost(function(err, title) {\n  $(\"h1\").html(title);\n});\n~~~\n\n### Use it to run promises\n\nIn the real world, you may be using libraries that only support Promises, and \nhave it play safe with libraries that use traditional callbacks.\n\nSafe-async helps you with this. Any safe-powered function you write can use \npromises. Instead of using the `next()` callback, make it return a promise object: \nsafe automatically knows what to do.\n\n~~~ js\ngetFirstPost = safe(function() {\n  return $.get(\"/posts.json\")\n  .then(function(data) {\n    return data.entries[0];\n  })\n  .then(function(post) {\n    return post.title;\n  });\n});\n~~~\n\nYou now get a function that can be used as a promise or an async function.\n\n~~~ js\ngetFirstPost(function(err, data) {\n  // used with a callback\n});\n\ngetFirstPost()\n.then(function(data) {\n  // used as a promise\n});\n~~~\n\nAPI\n---\n\n### `safe(fn)`\n\nA decorator that creates a function derived from `fn`, enhanced with safe-async\nsuperpowers.\n\nWhen this new function is invoked (`getName` in the example below), it runs `fn` \nwith the same arguments (`[a]` below), except with the last callback replaced \nwith a new callback called [next()](#next).\n\nWhen `next()` is invoked inside `[a]`, the callback given (`[b]`) will run.\n([next()](#next) is described in detail later below.)\n\n~~~ js\ngetName = safe(function(next) { //[a]\n  next(\"John\");\n});\n\ngetName(function(err, name) { //[b]\n  alert(\"Hey \" + name);\n});\n~~~\n\n__Arguments:__ All arguments will be passed through. In the example below, the \nnames passed onto `man` and `companion` are passed through as usual, but the \nlast argument (a function) has been changed to `next`.\n\n~~~ js\ngetMessage = safe(function(man, companion, next) {\n  var msg = \"How's it goin, \" + man + \" & \" + companion);\n  next(msg);\n});\n\ngetMessage(\"Doctor\", \"Donna\", function(err, msg) {\n  alert(msg);\n  /* => \"How's it goin, Doctor & Donna\" */\n});\n~~~\n\n__Errors:__ Any errors thrown inside `fn` will be passed the callback.\n\n~~~ js\ngetName = safe(function(next) {\n  var name = user.toUpperCase();\n  next(\"John\");\n});\n\ngetName(function(err, data) {\n  if (err) {\n    /* err.message === \"Cannot call method 'toUpperCase' of undefined\" */\n  }\n});\n~~~\n\n__Promises:__ The resulting function can be used as a promise as well.\n\n\n~~~ js\ngetName = safe(function(next) {\n  next(\"John\");\n});\n\ngetName()\n  .then(function(name) {\n    alert(\"Name: \"+name);\n  });\n~~~\n\n----\n\n### `safe.promise`\n\nThe promise provider function that allows you to plug in the promise library of\nyour choice.\n\n| Provider     | Code                                      |\n| ------------ | ----------------------------------------- |\n| [q.js]       | `safe.promise = require('q').promise;`    |\n| [when.js]    | `safe.promise = require('when').promise;` |\n| [promise.js] | `safe.promise = require('promise');`      |\n| [rsvp.js]    | `safe.promise = require('rsvp').Promise;` |\n\n`safe.promise` is expected to be a function used to create promises in this\nmanner below. Most promise libraries implement a function similar to this.\n\n~~~ js\nvar promise = safe.promise(function(ok, err, progress) {\n  ok(\"This returns a result\");\n  err(\"This returns an error\");\n  progress(\"This sends progress updates\");\n});\n~~~\n\n----\n\n### `next()`\n\nReturns a result and invokes the given callback (or resolves the promise, if \n    used as a promise).\n\nYou can return a result by calling `next(result)`.\n\n~~~ js\ngetName = safe(function(next) {\n  next(\"John\");\n});\n\ngetName(function(err, name) {\n  alert(\"Hey \" + name);\n});\n~~~\n\n__Returning errors:__ You may also return errors. You can do this by `throw`ing.\n\n~~~ js\ngetName = safe(function(next) {\n  throw new Error(\"Something happened\");\n}\n\ngetName(function(err, name) {\n  if (err) {\n    alert(err.message); //=> \"Something happened\"\n  }\n});\n~~~\n\n__Wrapping other callbacks:__ When `next()` is invoked with a function as an \nargument, it wraps (\"decorates\") that function to ensure that any errors it \nproduces is propagated properly. See [next.wrap()](#next-wrap).\n\n~~~ js\ngetArticles = safe(function(next) {\n  $.get('/articles.json', next(function(data) {\n    var articles = data.articles;\n    next(articles);\n  }));\n};\n\ngetArticles(function(err, articles) {\n  if (err)\n    console.error(\"Error:\", err);\n    /*=> \"TypeError: cannot read property 'articles' of undefined\" */\n  else\n    console.log(\"Articles:\", articles);\n});\n~~~\n\n__With promises:__ You can also return a promise from the function. Safe-async \nwill automatically figure out what to do from that.\n\n~~~ js\ngetFirstPost = safe(function() {\n  return $.get(\"/posts.json\")\n  .then(function(data) {\n    return data.entries[0];\n  })\n  .then(function(post) {\n    return post.title;\n  });\n});\n~~~\n\nYou now get a function that can be used as a promise or an async function.\n\n~~~ js\ngetFirstPost(function(err, data) {\n  // used with a callback\n});\n\ngetFirstPost()\n.then(function(data) {\n  // used as a promise\n});\n~~~\n\n----\n\n### `next.ok()`\n\nReturns a result. This is the same as calling `next()`.\n\n~~~ js\ngetName = safe(function(next) {\n  if (user.name)\n    next(user.name);\n  else\n    throw \"User has no name\";\n}\n~~~\n\n----\n\n### `next.err()`\n\nReturns an error. This is the same as `throw`ing an error, but is convenient\nwhen used inside deeper callbacks that you can't wrap with\n[next.wrap](#next-wrap).\n\n~~~ js\ngetName = safe(function(next) {\n  $.get(\"/user.json\")\n  .then(function(data) {\n    if (!data.name)\n      next.err(\"oops, no name here\");\n  })\n}\n~~~\n\n----\n\n### `next.wrap()`\n\nWraps a function (\"decorates\") to ensure that all errors it throws are\npropagated properly.\n\nWhen `next()` is invoked with a function as an argument, it works the same way\nas `next.wrap()`.\n\nIn this example below, any errors happening within the function `[a]` will be\nreported properly.\n\n~~~ js\ngetArticles = safe(function(next) {\n  $.get('/articles.json', next.wrap(function(data) { //[a]\n    var articles = data.articles;\n    next(articles);\n  }));\n};\n\ngetArticles(function(err, articles) {\n  if (err)\n    console.error(\"Error:\", err);\n    /*=> \"TypeError: cannot read property 'articles' of undefined\" */\n  else\n    console.log(\"Articles:\", articles);\n});\n~~~\n\nPractical uses\n--------------\n\n### [Express]\n\nSafe-async makes working with promises easy. It ensures that errors are \npropogated to the `next` callback, so you get errors rendered to your browser \ninstead of failing silently.\n\n~~~ coffee\napp.get '/feed', safe (req, res, next) ->\n  Article.fetchAll()\n  .then (articles) ->\n    res.locals.articles = articles\n    res.render \"index\"\n~~~\n\nAcknowledgements\n----------------\n\n© 2013, Rico Sta. Cruz. Released under the [MIT License].\n\n[MIT License]: http://www.opensource.org/licenses/mit-license.php\n[when.js]: https://github.com/cujojs/when\n[q.js]: https://github.com/kriskowal/q\n[promise.js]: https://github.com/then/promise\n[rsvp.js]: https://github.com/tildeio/rsvp.js\n[async.js]: https://github.com/caolan/async\n[Express]: http://expressjs.com\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/rstacruz/safe-async/issues"
  },
  "_id": "safe-async@0.1.1",
  "_from": "safe-async@"
}
